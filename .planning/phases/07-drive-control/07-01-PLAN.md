---
phase: 07-drive-control
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/HydraQuartetVCF.cpp
  - src/SVFilter.hpp
  - res/HydraQuartetVCF.svg
autonomous: true

must_haves:
  truths:
    - "Drive knob adds harmonic saturation to filtered signal"
    - "Drive at 0 produces clean (unaffected) signal"
    - "Full drive produces thick, compressed saturation (not harsh)"
    - "Drive CV modulates saturation amount with attenuverter control"
    - "LP/BP outputs receive more drive effect than HP output"
  artifacts:
    - path: "src/SVFilter.hpp"
      provides: "blendedSaturation function for waveshaping"
      contains: "blendedSaturation"
    - path: "src/HydraQuartetVCF.cpp"
      provides: "Drive parameter, CV input, attenuverter, output processing"
      contains: "DRIVE_CV_INPUT"
    - path: "res/HydraQuartetVCF.svg"
      provides: "Drive CV jack and attenuverter placeholder positions"
      contains: "drive-cv-input"
  key_links:
    - from: "src/HydraQuartetVCF.cpp"
      to: "src/SVFilter.hpp"
      via: "blendedSaturation function call"
      pattern: "blendedSaturation\\("
    - from: "params[DRIVE_PARAM]"
      to: "blendedSaturation"
      via: "drive parameter value"
      pattern: "driveParam.*blendedSaturation"
---

<objective>
Implement drive/saturation control with CV modulation for Oberheim filter character.

Purpose: Complete the v0.50b milestone by adding the final control - drive saturation that gives the filter its warm, fat character with harmonic content. This is the distinguishing feature that makes the filter sound musical rather than sterile.

Output: Working drive control with:
- Drive knob (0-1, default 0 for clean)
- Drive CV input with attenuverter
- Blended saturation algorithm (tanh + asymmetric for even+odd harmonics)
- Output-specific drive scaling (LP/BP full, HP reduced, Notch medium)
- Gain compensation for consistent loudness
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-drive-control/07-CONTEXT.md
@.planning/phases/07-drive-control/07-RESEARCH.md
@src/HydraQuartetVCF.cpp
@src/SVFilter.hpp
@res/HydraQuartetVCF.svg
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add drive CV input, attenuverter, and panel updates</name>
  <files>src/HydraQuartetVCF.cpp, res/HydraQuartetVCF.svg</files>
  <action>
Add drive control infrastructure following the cutoff/resonance pattern:

**In HydraQuartetVCF.cpp:**

1. Add to ParamId enum (after DRIVE_PARAM):
   - DRIVE_ATTEN_PARAM

2. Add to InputId enum:
   - DRIVE_CV_INPUT

3. In constructor, add configurations:
   - configParam(DRIVE_ATTEN_PARAM, -1.f, 1.f, 0.f, "Drive CV")
   - configInput(DRIVE_CV_INPUT, "Drive CV")

4. In HydraQuartetVCFWidget constructor, add components:
   Position drive section mirroring cutoff/resonance layout:
   - Drive knob stays at (55.0, 40.0) - move UP to Y=40 to match cutoff knob
   - Drive CV input at (55.0, 50.0) - below knob like cutoff CV
   - Drive attenuverter at (55.0, 62.0) - below CV like cutoff atten

   Use these widget additions:
   - Move existing drive knob: mm2px(Vec(55.0, 40.0)) with RoundBlackKnob (full size to match cutoff/resonance)
   - Add CV input: createInputCentered<PJ301MPort>(mm2px(Vec(55.0, 50.0)), module, HydraQuartetVCF::DRIVE_CV_INPUT)
   - Add attenuverter: createParamCentered<RoundSmallBlackKnob>(mm2px(Vec(55.0, 62.0)), module, HydraQuartetVCF::DRIVE_ATTEN_PARAM)

**In res/HydraQuartetVCF.svg:**

Update the components group to add drive CV and attenuverter placeholders:
- Update drive-knob to cx="55" cy="40" r="5" (full size knob)
- Add drive-cv-input: cx="55" cy="50" r="3.5" fill="#00ff00"
- Add drive-atten-knob: cx="55" cy="62" r="4" fill="#ff0000"
  </action>
  <verify>
Build compiles without errors: `cd /Users/trekkie/projects/vcvrack_modules/poly_obefilter && make clean && make`
  </verify>
  <done>
DRIVE_ATTEN_PARAM and DRIVE_CV_INPUT exist in enums. Widget has drive knob at Y=40, CV input at Y=50, attenuverter at Y=62. SVG has matching placeholder circles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement blended saturation algorithm</name>
  <files>src/SVFilter.hpp</files>
  <action>
Add the blendedSaturation function to SVFilter.hpp (outside the SVFilter struct, as a standalone inline function):

```cpp
// Blended saturation for drive control
// Combines soft tanh (odd harmonics) with asymmetric shaping (even harmonics)
inline float blendedSaturation(float x, float drive) {
    // True bypass at zero drive for clean signal
    if (drive < 0.01f) return x;

    // Input gain: 1x to 5x based on drive
    float gain = 1.0f + drive * 4.0f;
    float scaled = x * gain;

    // Soft saturation (symmetric - odd harmonics)
    float soft = std::tanh(scaled);

    // Asymmetric saturation (even + odd harmonics)
    float asym;
    if (scaled >= 0.0f) {
        asym = std::tanh(scaled);
    } else {
        // Harder curve below zero for asymmetry -> even harmonics
        asym = std::tanh(scaled * 1.3f) / 1.3f + scaled * 0.1f;
    }

    // Blend: more asymmetry at higher drive (up to 40%)
    float asymBlend = drive * 0.4f;
    float saturated = soft * (1.0f - asymBlend) + asym * asymBlend;

    // Moderate gain compensation (slight growth with drive for "excitement")
    float makeup = 1.0f / (1.0f + drive * 0.5f);

    return saturated * makeup;
}
```

Place this function after the SVFilterOutputs struct and before the SVFilter struct.

This implements the user's decision for:
- Blend of soft (tanh) and harder asymmetric edge
- Mix of even and odd harmonics
- Thick & compressed at max drive
- True bypass at drive=0 (clean)
  </action>
  <verify>
Build compiles: `cd /Users/trekkie/projects/vcvrack_modules/poly_obefilter && make`
  </verify>
  <done>
blendedSaturation function exists in SVFilter.hpp with tanh + asymmetric blending, gain compensation, and true bypass at drive < 0.01.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire drive processing into audio path with output-specific scaling</name>
  <files>src/HydraQuartetVCF.cpp</files>
  <action>
Integrate drive saturation into the process() function:

1. Add parameter smoother in SVFilter struct (or use local smoothing in process):
   Add at module level (in HydraQuartetVCF struct, after filters array):
   ```cpp
   rack::dsp::TExponentialFilter<float> driveSmoothers[PORT_MAX_CHANNELS];
   bool driveSmootherInitialized = false;
   ```

2. In constructor, after existing setup:
   ```cpp
   for (int i = 0; i < PORT_MAX_CHANNELS; i++) {
       driveSmoothers[i].setTau(0.001f);  // 1ms tau matches cutoff/resonance
   }
   ```

3. In process() function, after reading resonance parameters and before the per-voice loop:
   ```cpp
   float driveParam = params[DRIVE_PARAM].getValue();
   float driveCvAmount = params[DRIVE_ATTEN_PARAM].getValue();

   // Initialize smoothers on first call
   if (!driveSmootherInitialized) {
       for (int i = 0; i < PORT_MAX_CHANNELS; i++) {
           driveSmoothers[i].out = driveParam;
       }
       driveSmootherInitialized = true;
   }
   ```

4. Inside the per-voice loop (after filter processing, before output writes):
   ```cpp
   // Calculate per-voice drive (CV is polyphonic, same scaling as resonance: 10%/V)
   float drive = driveParam;
   if (inputs[DRIVE_CV_INPUT].isConnected()) {
       float driveCV = inputs[DRIVE_CV_INPUT].getPolyVoltage(c);
       drive = rack::clamp(driveParam + driveCV * driveCvAmount * 0.1f, 0.f, 1.f);
   }

   // Smooth drive parameter
   float smoothedDrive = driveSmoothers[c].process(1.f / args.sampleRate, drive);

   // Apply drive with output-specific scaling
   // LP/BP: full drive (low-frequency content saturates naturally)
   // HP: reduced drive (high-frequency less affected)
   // Notch: medium drive
   float lpOut = blendedSaturation(out.lowpass, smoothedDrive * 1.0f);
   float bpOut = blendedSaturation(out.bandpass, smoothedDrive * 1.0f);
   float hpOut = blendedSaturation(out.highpass, smoothedDrive * 0.5f);
   float notchOut = blendedSaturation(out.notch, smoothedDrive * 0.7f);

   // Write outputs for this channel
   outputs[LP_OUTPUT].setVoltage(lpOut, c);
   outputs[HP_OUTPUT].setVoltage(hpOut, c);
   outputs[BP_OUTPUT].setVoltage(bpOut, c);
   outputs[NOTCH_OUTPUT].setVoltage(notchOut, c);
   ```

   Note: Replace the existing output setVoltage calls with the new saturated outputs.
  </action>
  <verify>
Build and test:
1. `cd /Users/trekkie/projects/vcvrack_modules/poly_obefilter && make`
2. Load module in VCV Rack
3. Test: Drive at 0 = clean signal (no change)
4. Test: Drive at 1 = thick, compressed saturation on LP output
5. Test: HP output has less saturation than LP at same drive setting
6. Test: Drive CV modulation works with attenuverter
  </verify>
  <done>
Drive processing integrated into audio path. Drive CV with attenuverter modulates saturation. LP/BP outputs have full drive effect, HP has 50%, Notch has 70%. Parameter smoothing prevents zipper noise.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `make clean && make` produces plugin.dylib without errors
2. Module loads in VCV Rack without crashes
3. Drive at 0: Audio passes through unchanged (A/B test with bypass)
4. Drive at 1: Audible saturation on all outputs, LP/BP more affected than HP
5. Drive CV: Modulation affects saturation amount, attenuverter scales CV
6. No zipper noise when turning drive knob
7. Filter remains stable at all drive + resonance combinations
8. Self-oscillation (high resonance) sounds richer with drive
</verification>

<success_criteria>
- Drive knob (0-1) adds harmonic saturation to filtered signal
- Drive default 0 produces clean, unaffected signal (true bypass)
- Full drive produces thick, compressed sound (fat, not harsh)
- Drive CV input with attenuverter follows cutoff/resonance pattern
- LP/BP outputs get more drive effect than HP output
- Smooth parameter response without zipper noise
- Filter stable at all settings (no NaN, no blow-up)
</success_criteria>

<output>
After completion, create `.planning/phases/07-drive-control/07-01-SUMMARY.md`
</output>
