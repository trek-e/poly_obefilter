---
phase: 04-polyphonic-extension
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/HydraQuartetVCF.cpp
autonomous: true

must_haves:
  truths:
    - "Polyphonic input (1-16 channels) produces matching polyphonic output on all four outputs"
    - "Each voice is filtered independently (different CV produces different filtering)"
    - "Filter remains stable across all voices (no NaN, no crashes, no blow-up)"
  artifacts:
    - path: "src/HydraQuartetVCF.cpp"
      provides: "Polyphonic filter processing"
      contains: "SVFilter filters[PORT_MAX_CHANNELS]"
  key_links:
    - from: "process() loop"
      to: "filters[c]"
      via: "per-channel iteration"
      pattern: "filters\\[c\\]\\.process"
    - from: "CV inputs"
      to: "per-voice parameters"
      via: "getPolyVoltage(c)"
      pattern: "getPolyVoltage\\(c\\)"
    - from: "outputs"
      to: "channel count"
      via: "setChannels()"
      pattern: "setChannels\\(channels\\)"
---

<objective>
Transform the monophonic HydraQuartetVCF into a polyphonic processor supporting up to 16 voices.

Purpose: Enable polyphonic patches where each voice in a chord/sequence gets independent filter processing
Output: Working polyphonic filter module with per-voice CV modulation
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-polyphonic-extension/04-CONTEXT.md
@.planning/phases/04-polyphonic-extension/04-RESEARCH.md
@src/SVFilter.hpp
@src/HydraQuartetVCF.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Filter Array for Polyphonic Processing</name>
  <files>src/HydraQuartetVCF.cpp</files>
  <action>
Replace the single `SVFilter filter;` member with an array:
```cpp
SVFilter filters[PORT_MAX_CHANNELS];  // 16 filter instances for polyphony
```

The existing SVFilter class already has:
- Per-instance state (ic1eq, ic2eq, coefficients)
- Parameter smoothers (cutoffSmoother, resonanceSmoother)
- NaN protection with reset()

No changes needed to SVFilter.hpp - the scalar implementation is correct for this phase.
  </action>
  <verify>Code compiles: `make -j4` succeeds with no errors</verify>
  <done>Module has array of 16 SVFilter instances instead of single filter</done>
</task>

<task type="auto">
  <name>Task 2: Implement Polyphonic Process Loop</name>
  <files>src/HydraQuartetVCF.cpp</files>
  <action>
Rewrite the process() method to handle polyphonic signals:

1. **Get channel count from audio input:**
```cpp
int channels = std::max(1, inputs[AUDIO_INPUT].getChannels());
```

2. **Move parameter calculation inside per-channel loop** for per-voice CV:
```cpp
for (int c = 0; c < channels; c++) {
    // Read per-voice audio
    float input = inputs[AUDIO_INPUT].getPolyVoltage(c);

    // Read cutoff (per-voice CV if connected)
    float cutoffParam = params[CUTOFF_PARAM].getValue();
    float baseCutoffHz = 20.f * std::pow(1000.f, cutoffParam);
    float cutoffHz = baseCutoffHz;
    if (inputs[CUTOFF_CV_INPUT].isConnected()) {
        float cutoffCV = inputs[CUTOFF_CV_INPUT].getPolyVoltage(c);
        float cvAmount = params[CUTOFF_ATTEN_PARAM].getValue();
        cutoffHz = baseCutoffHz * std::pow(2.f, cutoffCV * cvAmount);
    }
    cutoffHz = rack::clamp(cutoffHz, 20.f, 20000.f);

    // Read resonance (per-voice CV if connected)
    float resonanceParam = params[RESONANCE_PARAM].getValue();
    if (inputs[RESONANCE_CV_INPUT].isConnected()) {
        float resCV = inputs[RESONANCE_CV_INPUT].getPolyVoltage(c);
        resonanceParam = rack::clamp(resonanceParam + resCV * 0.1f, 0.f, 1.f);
    }

    // Process through this voice's filter
    filters[c].setParams(cutoffHz, resonanceParam, args.sampleRate);
    SVFilterOutputs out = filters[c].process(input);

    // Write outputs for this channel
    outputs[LP_OUTPUT].setVoltage(out.lowpass, c);
    outputs[HP_OUTPUT].setVoltage(out.highpass, c);
    outputs[BP_OUTPUT].setVoltage(out.bandpass, c);
    outputs[NOTCH_OUTPUT].setVoltage(out.notch, c);
}
```

3. **Set output channel counts after the loop:**
```cpp
outputs[LP_OUTPUT].setChannels(channels);
outputs[HP_OUTPUT].setChannels(channels);
outputs[BP_OUTPUT].setChannels(channels);
outputs[NOTCH_OUTPUT].setChannels(channels);
```

Key points:
- `getPolyVoltage(c)` handles CV wrapping automatically (mono CV copies to all voices)
- Each voice has independent filter state in filters[c]
- Resonance CV scaled by 0.1 (1V = 10% resonance change) to prevent wild swings
- All four outputs are polyphonic with matching channel count
  </action>
  <verify>
Build succeeds: `make -j4`
Load in VCV Rack: Module loads without crash
Test mono: Connect mono source, verify 1-channel output
Test poly: Connect 4-voice poly source, verify 4-channel output on all outputs
  </verify>
  <done>
Process loop iterates over channels, each voice has independent filter, all outputs are polyphonic
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify Polyphonic Behavior in VCV Rack</name>
  <files>src/HydraQuartetVCF.cpp</files>
  <action>
Test the polyphonic module behavior:

1. **Test Setup:**
   - Build and install: `make install`
   - Open VCV Rack
   - Create test patch: POLY MERGE (4 voices) -> HydraQuartetVCF -> POLY SPLIT -> 4x scopes

2. **Verify Channel Count Propagation:**
   - Right-click cables to inspect channel count
   - Input: Should show N channels
   - All outputs: Should show same N channels

3. **Verify Independent Voice Processing:**
   - Connect polyphonic CV to CUTOFF_CV_INPUT
   - Each voice should filter differently
   - Listen: Distinct timbres per voice

4. **Verify Stability:**
   - Set resonance to max (self-oscillation)
   - Run for 30+ seconds
   - No NaN, no blow-up, no crashes

5. **Edge Cases:**
   - Mono input: Should work as single voice
   - No input connected: No crash
   - Hot-swap poly count: Change source voice count while running

If any stability issues found, add debugging output to identify which voice fails.
  </action>
  <verify>
All tests pass:
- Channel count matches input on all outputs
- Per-voice CV produces audibly different filtering
- No instability at high resonance
- No crashes on edge cases
  </verify>
  <done>
Polyphonic behavior verified working: independent voice processing, stable operation, correct channel propagation
  </done>
</task>

</tasks>

<verification>
Phase 4 Success Criteria (from ROADMAP.md):
1. [x] Module accepts polyphonic cable input (1-8 channels)
2. [x] Each voice processes independently with separate filter state
3. [x] Filter remains stable (no blow-up, NaN, or crashes)
4. [x] Polyphonic patch produces 8 distinct filtered voices

Additional verification:
- Right-click output cable shows correct channel count
- Per-voice CV modulation audibly affects each voice differently
- Works with 1-16 voices (VCV Rack maximum)
</verification>

<success_criteria>
1. Polyphonic input produces matching polyphonic outputs on LP, HP, BP, and Notch
2. Each voice is filtered independently (filters[c] has independent state)
3. Per-voice CV on cutoff and resonance affects each voice separately
4. Filter stable at all resonance settings across all voices
5. Build succeeds with no warnings related to polyphony
</success_criteria>

<output>
After completion, create `.planning/phases/04-polyphonic-extension/04-01-SUMMARY.md`
</output>
