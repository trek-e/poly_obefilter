# Phase 1: Foundation - Research

**Researched:** 2026-01-30
**Domain:** VCV Rack Plugin Development
**Confidence:** HIGH

## Summary

VCV Rack plugin development uses a C++11-based SDK with a standardized build system centered on Makefiles. The current production version is Rack SDK 2.6 (major version 2), requiring all plugins to compile against the v2 SDK with matching major version numbers. The development workflow relies on three core components: a standardized directory structure generated by helper.py scripts, SVG-based panel design using Inkscape with color-coded component placeholders, and metadata configuration through plugin.json manifests.

The standard approach follows VCV's official tooling throughout. The helper.py script scaffolds initial plugin structure and auto-generates C++ widget instantiation code from SVG component layers. Panels are designed at exact physical dimensions (128.5mm height, 5.08mm per HP width) with components marked on a hidden "components" layer using specific colors (red for parameters, green for inputs, blue for outputs, magenta for lights). The Makefile delegates to Rack SDK's plugin.mk framework, requiring only the RACK_DIR environment variable and source file listings.

Critical constraints include: plugin major version must match Rack major version (currently 2.x), all SVG text must be converted to paths, plugin.json slug cannot change post-release, and the component library is CC BY-NC 4.0 (noncommercial use only). The HydraQuartet VCO reference project demonstrates the exact visual style and branding to match.

**Primary recommendation:** Use VCV's helper.py for both plugin scaffolding and module code generation from SVG panels. Follow the SDK-provided Makefile pattern without customization. Design panels in Inkscape at exact Eurorack dimensions with the standard component placeholder workflow.

## Standard Stack

The established tools for VCV Rack plugin development:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| VCV Rack SDK | 2.6 (v2.x) | Plugin development framework | Official SDK, provides plugin.mk build system and component library |
| C++ Compiler | C++11 standard | Plugin compilation | Required by SDK, uses -std=c++11 flag |
| Inkscape | 1.x | Panel SVG design | Official recommendation, tested with helper.py script |
| helper.py | Included in SDK | Plugin/module scaffolding | Official code generation tool, part of SDK |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| Git | Latest | Version control and VCV Library submission | Required for Library submissions, tagging releases |
| Make | Latest | Build system | Required for compilation, SDK uses Makefile pattern |
| MSYS2 (Windows) | Latest | Windows build environment | Windows development only |
| Homebrew (Mac) | Latest | Mac dependency manager | Mac development only |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| SDK approach | Build Rack from source | SDK is easier, source approach for Rack core development only |
| Inkscape | Programmatic SVG generation | Inkscape is visual and matches official workflow, programmatic harder to verify dimensions |
| helper.py | Manual code writing | helper.py prevents coordinate errors and ensures correct widget positioning |

**Installation:**
```bash
# Download VCV Rack SDK from https://vcvrack.com/downloads/
# Extract to desired location (e.g., ~/Rack-SDK)

# Set environment variable (add to ~/.bashrc or ~/.zshrc)
export RACK_DIR=~/Rack-SDK

# Install platform-specific dependencies:
# Mac:
brew install git wget cmake autoconf automake libtool jq python zstd pkg-config

# Windows (MSYS2 MinGW 64-bit shell):
pacman -S git wget make tar unzip zip mingw-w64-x86_64-gcc mingw-w64-x86_64-gdb mingw-w64-x86_64-cmake autoconf automake libtool mingw-w64-x86_64-jq python zstd mingw-w64-x86_64-pkgconf

# Linux (Ubuntu 16.04+):
# Install via apt (development tools and audio/graphics libraries)
```

## Architecture Patterns

### Recommended Project Structure
```
HydraQuartetVCF/
├── src/                 # C++ source files
│   ├── plugin.cpp       # Plugin registration (lowercase)
│   └── HydraQuartetVCF.cpp  # Module implementation (PascalCase)
├── res/                 # Resources directory
│   └── HydraQuartetVCF.svg  # Panel design (matches module slug)
├── presets/             # Factory presets (optional)
├── plugin.json          # Plugin manifest (required)
├── Makefile             # Build configuration (required)
├── LICENSE.txt          # License file (recommended)
└── README.md            # Documentation (recommended)
```

### Pattern 1: Plugin Scaffolding with helper.py
**What:** Generate initial plugin structure using SDK's helper.py script
**When to use:** Starting new plugin from scratch
**Example:**
```bash
# Source: https://vcvrack.com/manual/PluginDevelopmentTutorial
cd ~/projects
$RACK_DIR/helper.py createplugin MyPlugin

# Creates complete plugin structure with:
# - plugin.json manifest
# - Makefile
# - src/plugin.cpp
# - res/ directory
```

### Pattern 2: SVG-Based Panel Design
**What:** Design panel in Inkscape with component placeholder layer, generate C++ code automatically
**When to use:** Creating or updating module panels
**Example:**
```bash
# Source: https://vcvrack.com/manual/Panel
# 1. Design panel in Inkscape:
#    - Document: 128.5mm height × (HP × 5.08mm) width
#    - Create "components" layer for placeholders
#    - Red circles (#ff0000) for params
#    - Green circles (#00ff00) for inputs
#    - Blue circles (#0000ff) for outputs
#    - Magenta circles (#ff00ff) for lights
#    - Convert all text to paths (Path > Object to Path)
#    - Hide components layer before saving

# 2. Generate module code:
$RACK_DIR/helper.py createmodule MyModule res/MyModule.svg src/MyModule.cpp

# This generates C++ file with:
# - createParamCentered() calls for red circles
# - createInputCentered() calls for green circles
# - createOutputCentered() calls for blue circles
# - createLightCentered() calls for magenta circles
```

### Pattern 3: Plugin Manifest Configuration
**What:** Define plugin metadata, modules, and tags in plugin.json
**When to use:** Initial setup and when adding/updating modules
**Example:**
```json
// Source: https://vcvrack.com/manual/Manifest
{
  "slug": "Synth-eticIntelligence",
  "name": "Synth-etic Intelligence",
  "version": "2.0.0",
  "license": "GPL-3.0-or-later",
  "brand": "Synth-etic Intelligence",
  "author": "Synth-etic Intelligence",
  "authorEmail": "syntheticint@thepainterofsilence.com",
  "sourceUrl": "https://github.com/trek-e/HydraQuartetVCF",
  "modules": [
    {
      "slug": "HydraQuartetVCF",
      "name": "HydraQuartet VCF-OB",
      "description": "8-voice Oberheim-style multimode filter",
      "tags": [
        "Filter",
        "Polyphonic",
        "VCF",
        "Multimode"
      ]
    }
  ]
}
```

### Pattern 4: Standard Makefile Structure
**What:** Minimal Makefile that delegates to SDK's plugin.mk
**When to use:** All plugins (generated by helper.py)
**Example:**
```makefile
# Source: https://github.com/trek-e/HydraQuartet/blob/main/Makefile
RACK_DIR ?= ../Rack-SDK

FLAGS +=
CFLAGS +=
CXXFLAGS +=
LDFLAGS +=

SOURCES += $(wildcard src/*.cpp)

DISTRIBUTABLES += res presets LICENSE.txt

include $(RACK_DIR)/plugin.mk
```

### Pattern 5: Module Class Structure
**What:** Module class inheriting from rack::Module with config() and process() methods
**When to use:** Every module implementation
**Example:**
```cpp
// Source: https://vcvrack.com/manual/PluginGuide
struct MyModule : Module {
    enum ParamId {
        CUTOFF_PARAM,
        PARAMS_LEN
    };
    enum InputId {
        AUDIO_INPUT,
        INPUTS_LEN
    };
    enum OutputId {
        AUDIO_OUTPUT,
        OUTPUTS_LEN
    };
    enum LightId {
        LIGHTS_LEN
    };

    MyModule() {
        config(PARAMS_LEN, INPUTS_LEN, OUTPUTS_LEN, LIGHTS_LEN);
        configParam(CUTOFF_PARAM, 0.f, 1.f, 0.5f, "Cutoff");
        configInput(AUDIO_INPUT, "Audio");
        configOutput(AUDIO_OUTPUT, "Audio");
    }

    void process(const ProcessArgs& args) override {
        // DSP processing here
    }
};
```

### Pattern 6: Polyphonic Processing
**What:** Handle polyphonic cables with channel-aware processing
**When to use:** Modules supporting polyphony (8-voice for HydraQuartet)
**Example:**
```cpp
// Source: https://vcvrack.com/manual/PluginGuide
void process(const ProcessArgs& args) override {
    int channels = std::max(1, inputs[AUDIO_INPUT].getChannels());

    for (int c = 0; c < channels; c++) {
        float input = inputs[AUDIO_INPUT].getPolyVoltage(c);
        // Process per channel
        float output = processAudio(input, c);
        outputs[AUDIO_OUTPUT].setVoltage(output, c);
    }

    outputs[AUDIO_OUTPUT].setChannels(channels);
}
```

### Anti-Patterns to Avoid
- **Custom build systems:** Don't replace SDK's plugin.mk framework, it handles cross-platform compilation correctly
- **Pixel-based SVG dimensions:** Always use millimeters, pixels are unsupported
- **Manual widget positioning:** Don't hand-code widget coordinates, use helper.py to extract from SVG
- **Version mismatch:** Plugin major version must match Rack major version (2.x for Rack 2.x)
- **Changing slugs:** Plugin and module slugs cannot change after first release, breaks user patches
- **Large JSON data:** Don't store >100kB in JSON, use createPatchStorageDirectory() for large data
- **Direct expander access:** Don't access expander module variables directly, causes latency issues

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Plugin scaffolding | Manual directory/file creation | helper.py createplugin | Generates correct structure, plugin.json, Makefile, ensures SDK compatibility |
| Widget positioning | Manual coordinate calculation | helper.py createmodule with SVG | Extracts exact positions from Inkscape, prevents alignment errors |
| Build system | Custom Makefile or CMake | SDK's plugin.mk | Handles cross-platform compilation, dependency management, distribution packaging |
| Component graphics | Custom SVG widgets | rack::componentlibrary | Provides tested knobs/ports/lights, consistent visual language |
| Panel dimensions | Manual HP calculation | Inkscape with 128.5mm × (HP × 5.08mm) | Ensures exact Eurorack dimensions, matches physical hardware |
| Widget types | Generic Widget subclasses | createParam/Input/Output helpers | Proper parameter ranges, voltage standards, tooltips |
| Polyphonic handling | Manual channel management | getChannels()/getPolyVoltage()/setChannels() | Handles mono/poly compatibility, proper voltage scaling |
| Text rendering in SVG | SVG text elements | Path > Object to Path in Inkscape | NanoVG renderer doesn't support SVG text, must be paths |

**Key insight:** VCV's SDK provides automation for every scaffolding and code-generation task. Manual approaches introduce coordinate errors, build system incompatibilities, and cross-platform issues. The helper.py workflow is battle-tested across hundreds of plugins.

## Common Pitfalls

### Pitfall 1: Incorrect Panel Dimensions
**What goes wrong:** Panel doesn't fit Rack's module browser or appears distorted
**Why it happens:** Using pixels instead of millimeters, or incorrect HP width calculation
**How to avoid:**
- Set Inkscape document to millimeters (Document Properties > Display units: mm)
- Height: exactly 128.5mm (never change this)
- Width: HP × 5.08mm (12HP = 60.96mm, 14HP = 71.12mm)
- Verify units before saving SVG
**Warning signs:** Module appears stretched or compressed, doesn't align with adjacent modules

### Pitfall 2: Version Number Mismatch
**What goes wrong:** Plugin fails to load in Rack, appears grayed out in library
**Why it happens:** Plugin major version doesn't match Rack major version
**How to avoid:**
- Rack 2.x requires plugin version 2.x.x
- First number must match: plugin v2.4.2 works with Rack 2.6.0
- Update version in plugin.json when migrating between Rack versions
**Warning signs:** "Plugin is for Rack v1" error message, module doesn't appear in browser

### Pitfall 3: SVG Text Not Converted to Paths
**What goes wrong:** Panel labels render as black rectangles or don't appear
**Why it happens:** NanoVG renderer doesn't support SVG text elements
**How to avoid:**
- Before saving final SVG: Select All > Path > Object to Path in Inkscape
- Verify by reopening SVG and checking if text can be edited (shouldn't be editable)
- Keep a separate .svg copy with editable text for future changes
**Warning signs:** Labels missing or appearing as solid black shapes

### Pitfall 4: Components Layer Visible in Final SVG
**What goes wrong:** Colored placeholder circles appear on rendered panel
**Why it happens:** Forgot to hide components layer before saving
**How to avoid:**
- Open Layers panel (Ctrl+Shift+L)
- Click eye icon next to "components" layer to hide
- Save SVG with layer hidden
- Layer is only for helper.py extraction, never part of visual design
**Warning signs:** Red/green/blue/magenta circles visible on panel in Rack

### Pitfall 5: Missing or Incorrect RACK_DIR
**What goes wrong:** Build fails with "No rule to make target 'plugin.mk'" error
**Why it happens:** RACK_DIR environment variable not set or pointing to wrong location
**How to avoid:**
- Add `export RACK_DIR=/path/to/Rack-SDK` to ~/.bashrc or ~/.zshrc
- Restart terminal or run `source ~/.bashrc` after adding
- Verify with `echo $RACK_DIR` before running make
- Makefile's `RACK_DIR ?= ../Rack-SDK` is fallback, not reliable for all setups
**Warning signs:** Compilation errors about missing files, "plugin.mk not found"

### Pitfall 6: Improper Module Slug Changes
**What goes wrong:** Users' patches break, modules disappear from saved patches
**Why it happens:** Changed slug in plugin.json after initial release
**How to avoid:**
- Choose slugs carefully during initial development
- Once published to VCV Library, slug is permanent
- If must change, document migration path in changelog
- Consider using hidden: true for old slug and new slug for updated version
**Warning signs:** User reports of missing modules after update

### Pitfall 7: Case Sensitivity in File References
**What goes wrong:** Plugin compiles on Mac/Windows but fails on Linux
**Why it happens:** Inconsistent case in #include statements or file references
**How to avoid:**
- Match exact case in #include statements and actual filenames
- Test on Linux or use case-sensitive file system
- Follow convention: PascalCase for module files, lowercase for standard files
**Warning signs:** Build succeeds locally but fails in CI or on other platforms

### Pitfall 8: Missing Module Metadata
**What goes wrong:** Module hard to discover in browser, unclear purpose
**Why it happens:** Empty or minimal description, no tags in plugin.json
**How to avoid:**
- Add description field to modules[] entries
- Include relevant tags from official list (Filter, Polyphonic, etc.)
- Set manualUrl to README or documentation
**Warning signs:** Module appears in browser with no description or wrong category

### Pitfall 9: Component Library Licensing Confusion
**What goes wrong:** Commercial plugin uses CC BY-NC components, licensing conflict
**Why it happens:** Assuming component library is freely usable for commercial purposes
**How to avoid:**
- Component library SVGs are CC BY-NC 4.0 (noncommercial only)
- For commercial plugins: design custom widgets or license separately
- Document component usage in LICENSE.txt
**Warning signs:** Using RoundBlackKnob, PJ301MPort, etc. in commercial product

### Pitfall 10: Polyphonic Cable Misconfiguration
**What goes wrong:** Module processes only first channel, ignores polyphonic inputs
**Why it happens:** Not calling getChannels() or forgetting setChannels() on outputs
**How to avoid:**
- Always call `int channels = inputs[X].getChannels()` at start of process()
- Loop through channels: `for (int c = 0; c < channels; c++)`
- Set output channels: `outputs[Y].setChannels(channels)` after loop
**Warning signs:** Polyphonic cables connected but only one voice sounds

## Code Examples

Verified patterns from official sources:

### Plugin Registration (plugin.cpp)
```cpp
// Source: https://vcvrack.com/manual/PluginDevelopmentTutorial
#include "plugin.hpp"

Plugin* pluginInstance;

void init(Plugin* p) {
    pluginInstance = p;
    p->addModel(modelHydraQuartetVCF);
}
```

### Module Widget with Standard Components
```cpp
// Source: https://vcvrack.com/docs-v2/namespacerack_1_1componentlibrary
struct HydraQuartetVCFWidget : ModuleWidget {
    HydraQuartetVCFWidget(HydraQuartetVCF* module) {
        setModule(module);
        setPanel(createPanel(asset::plugin(pluginInstance, "res/HydraQuartetVCF.svg")));

        addChild(createWidget<ScrewSilver>(Vec(RACK_GRID_WIDTH, 0)));
        addChild(createWidget<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));

        // Medium-sized knob (standard VCV size)
        addParam(createParamCentered<RoundBlackKnob>(mm2px(Vec(30.0, 40.0)), module, HydraQuartetVCF::CUTOFF_PARAM));

        // Audio input (top left convention)
        addInput(createInputCentered<PJ301MPort>(mm2px(Vec(10.0, 20.0)), module, HydraQuartetVCF::AUDIO_INPUT));

        // Filter outputs section
        addOutput(createOutputCentered<PJ301MPort>(mm2px(Vec(50.0, 80.0)), module, HydraQuartetVCF::LP_OUTPUT));
        addOutput(createOutputCentered<PJ301MPort>(mm2px(Vec(50.0, 95.0)), module, HydraQuartetVCF::HP_OUTPUT));
    }
};
```

### Polyphonic Processing Pattern
```cpp
// Source: https://vcvrack.com/manual/PluginGuide
void process(const ProcessArgs& args) override {
    // Get number of channels from input
    int channels = std::max(1, inputs[AUDIO_INPUT].getChannels());

    // Process each channel independently
    for (int c = 0; c < channels; c++) {
        float input = inputs[AUDIO_INPUT].getPolyVoltage(c);
        float cutoff = params[CUTOFF_PARAM].getValue();

        // Apply per-voice processing
        float output = filterVoice[c].process(input, cutoff);

        outputs[LP_OUTPUT].setVoltage(output, c);
    }

    // Set output channel count
    outputs[LP_OUTPUT].setChannels(channels);
}
```

### Build Commands
```bash
# Source: https://vcvrack.com/manual/Building
# Initial setup (if plugin has submodules or dependencies)
git submodule update --init --recursive
make dep

# Compile plugin
make

# Create distributable package
make dist

# Install directly to Rack user folder for testing
make install
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Rack v1 SDK | Rack v2 SDK | 2021 | Major version matching required, new patch format (.vcv archives) |
| Manual widget positioning | helper.py SVG extraction | Rack v1 era | Eliminated coordinate calculation errors |
| Pixels in SVG | Millimeters required | Rack v2 | Exact physical dimensions, eliminates scaling issues |
| Custom component SVGs | Component library | Early Rack development | Consistent UI, but limits commercial use (CC BY-NC) |
| C++11 standard | Still C++11 | Ongoing | Stability over new features, some plugins use C++17 |

**Deprecated/outdated:**
- Rack v0.6 plugin format: Complete rewrite required for v1/v2
- Manual ModuleWidget constructors: Use helper.py generated code
- Text elements in SVG: Must be converted to paths for NanoVG renderer
- Branch names for Library submissions: Must use full commit hash (git rev-parse HEAD)

## Open Questions

1. **HydraQuartet VCO Panel SVG Access**
   - What we know: GitHub repository exists, visual style documented
   - What's unclear: Whether SVG source file is in repository or needs to be recreated
   - Recommendation: Check repository res/ directory, if not present, recreate based on visual style guidelines and color palette

2. **Current Rack SDK Installation Location**
   - What we know: SDK must be downloaded and RACK_DIR set
   - What's unclear: Where on the development system the SDK is currently installed
   - Recommendation: Determine location before starting build, add to shell environment permanently

3. **Commercial vs. Noncommercial License Intent**
   - What we know: GPL-3.0 chosen, component library is CC BY-NC
   - What's unclear: Whether future commercial distribution is planned
   - Recommendation: Document that standard components limit to noncommercial; custom widgets needed for commercial

4. **Exact HP Width Choice (12 or 14)**
   - What we know: User specified "12-14 HP"
   - What's unclear: Final decision between 12HP (60.96mm) or 14HP (71.12mm)
   - Recommendation: Decide based on component count and layout density before Inkscape work

5. **DSP Library Separation Strategy**
   - What we know: Context specifies "filter DSP in separate file from module class"
   - What's unclear: Whether to use existing Oberheim filter implementations or build from scratch
   - Recommendation: Research begins in Phase 2, document as separate concern for Phase 1

## Sources

### Primary (HIGH confidence)
- [VCV Rack Plugin Development Tutorial](https://vcvrack.com/manual/PluginDevelopmentTutorial) - Complete workflow, helper.py usage
- [VCV Rack Module Panel Guide](https://vcvrack.com/manual/Panel) - SVG dimensions, component placeholders, Inkscape workflow
- [VCV Rack Plugin Manifest](https://vcvrack.com/manual/Manifest) - plugin.json schema, all required/optional fields
- [VCV Rack Plugin API Guide](https://vcvrack.com/manual/PluginGuide) - Module class structure, polyphonic handling, anti-patterns
- [VCV Rack Building Guide](https://vcvrack.com/manual/Building) - Dependencies, Makefile structure, compilation commands
- [VCV Rack Component Library API](https://vcvrack.com/docs-v2/namespacerack_1_1componentlibrary) - Available knobs, ports, lights, switches
- [VCV Library README](https://github.com/VCVRack/library/blob/master/README.md) - Submission requirements, validation rules
- [HydraQuartet GitHub Repository](https://github.com/trek-e/HydraQuartet) - Reference project structure and plugin.json

### Secondary (MEDIUM confidence)
- [VCV Rack Migrating v1 to v2](https://vcvrack.com/manual/Migrate2) - Version matching requirements, breaking changes
- [VCV Rack CHANGELOG](https://github.com/VCVRack/Rack/blob/v2/CHANGELOG.md) - Version history, current SDK version 2.6
- [VCV Community: Common Plugin Issues](https://community.vcvrack.com/t/help-wanted-for-reporting-common-issues-to-rack-plugin-developers/11031) - Real-world pitfalls
- [VCV Community: C++ Standard](https://community.vcvrack.com/t/c-guide/1717) - Confirmed C++11 standard, -std=c++11 flag

### Tertiary (LOW confidence)
- VCV Rack 2.6 release news (2025-03-27) - Current version confirmation via WebSearch
- Synth Panels Designer tool - Alternative Inkscape workflow, not verified with official docs

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All tools and versions verified from official VCV documentation and SDK
- Architecture: HIGH - Patterns extracted from official manual and API docs with working examples
- Pitfalls: MEDIUM-HIGH - Mix of official documentation and community reports, cross-verified

**Research date:** 2026-01-30
**Valid until:** 2026-02-28 (30 days) - VCV Rack stable, but minor SDK updates possible
