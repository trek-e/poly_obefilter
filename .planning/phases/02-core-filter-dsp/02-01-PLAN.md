---
phase: 02-core-filter-dsp
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/SVFilter.hpp
  - src/HydraQuartetVCF.cpp
autonomous: false

must_haves:
  truths:
    - "Audio passes through module with lowpass filtering applied"
    - "Filter cutoff knob sweeps frequency across audible range"
    - "High resonance produces self-oscillation (audible sine tone)"
    - "Filter remains stable (no blow-up, NaN, or crashes)"
  artifacts:
    - path: "src/SVFilter.hpp"
      provides: "Trapezoidal SVF class with setParams() and process()"
      min_lines: 50
      contains: "ic1eq"
    - path: "src/HydraQuartetVCF.cpp"
      provides: "DSP processing in process() method"
      contains: "filter.process"
  key_links:
    - from: "src/HydraQuartetVCF.cpp"
      to: "src/SVFilter.hpp"
      via: "#include and SVFilter member"
      pattern: '#include "SVFilter.hpp"'
    - from: "HydraQuartetVCF::process()"
      to: "SVFilter::process()"
      via: "filter.process() call in audio loop"
      pattern: "filter\\.process\\("
    - from: "params[CUTOFF_PARAM]"
      to: "filter.setParams()"
      via: "parameter reading and coefficient calculation"
      pattern: "setParams.*cutoff"
---

<objective>
Implement the core SEM-style 12dB state-variable filter DSP that processes audio through the module.

Purpose: This is the heart of the HydraQuartet VCF-OB - the actual filter processing that gives it the distinctive Oberheim sound. Without this, the module is just a pretty panel.

Output: Working lowpass filter with cutoff/resonance control, audible filtering, and self-oscillation at high resonance.
</objective>

<execution_context>
@/Users/trekkie/.claude/get-shit-done/workflows/execute-plan.md
@/Users/trekkie/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase research with code examples
@.planning/phases/02-core-filter-dsp/02-RESEARCH.md
@.planning/phases/02-core-filter-dsp/02-CONTEXT.md

# Prior phase for context on what exists
@.planning/phases/01-foundation/01-01-SUMMARY.md

# Current module code to modify
@src/HydraQuartetVCF.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SVFilter class</name>
  <files>src/SVFilter.hpp</files>
  <action>
Create a header-only SVFilter class implementing trapezoidal SVF with soft saturation.

**Structure:**
```cpp
#pragma once
#include "rack.hpp"

struct SVFilter {
    // State variables (integrator outputs)
    float ic1eq = 0.f;
    float ic2eq = 0.f;

    // Coefficients
    float g, k, a1, a2, a3;

    // Parameter smoothing
    rack::dsp::TExponentialFilter<float> cutoffSmoother;
    rack::dsp::TExponentialFilter<float> resonanceSmoother;

    void setParams(float cutoffHz, float resonance, float sampleRate);
    float process(float input);
    void reset();
};
```

**setParams() implementation:**
- Smooth cutoff and resonance using TExponentialFilter with ~1ms tau
- Apply frequency warping: `g = tan(M_PI * cutoffNorm)` where cutoffNorm = clamp(cutoffHz/sampleRate, 0, 0.49)
- Map resonance 0-1 to Q range via `k = 1.f / (0.5f + resonance * 19.5f)` (Q from 0.5 to 20)
- Pre-compute coefficients: a1 = 1/(1+g*(g+k)), a2 = g*a1, a3 = g*a2

**process() implementation:**
- Trapezoidal SVF equations from 02-RESEARCH.md
- Apply soft saturation (tanh) in feedback path for Oberheim character
- Return lowpass output (v2)
- Check isfinite() on output, reset if NaN

**reset() implementation:**
- Zero ic1eq and ic2eq

Do NOT add DC blocking yet (per research: test first, add if needed).
Do NOT add oversampling yet (Phase 3+ feature).
  </action>
  <verify>File exists at src/SVFilter.hpp with struct SVFilter containing ic1eq, ic2eq state variables, setParams(), process(), and reset() methods. No compilation errors when included.</verify>
  <done>SVFilter.hpp contains complete trapezoidal SVF implementation with soft saturation, parameter smoothing, and NaN protection.</done>
</task>

<task type="auto">
  <name>Task 2: Wire filter into module process()</name>
  <files>src/HydraQuartetVCF.cpp</files>
  <action>
Modify HydraQuartetVCF.cpp to use SVFilter for audio processing.

**Add include:**
```cpp
#include "SVFilter.hpp"
```

**Add member variable** to HydraQuartetVCF struct:
```cpp
SVFilter filter;
```

**Implement process() method:**

1. **Read parameters:**
   - cutoffParam = params[CUTOFF_PARAM].getValue() (0-1)
   - Map to frequency: baseCutoffHz = 20.f * pow(1000.f, cutoffParam) (20Hz-20kHz log)
   - resonanceParam = params[RESONANCE_PARAM].getValue() (0-1)

2. **Read CV inputs (if connected):**
   - If CUTOFF_CV_INPUT connected: apply 1V/oct scaling
   - cutoffCV = inputs[CUTOFF_CV_INPUT].getVoltage()
   - cvAmount = params[CUTOFF_ATTEN_PARAM].getValue() (attenuverter, -1 to +1)
   - cutoffHz = baseCutoffHz * pow(2.f, cutoffCV * cvAmount)
   - Clamp cutoffHz to 20-20000 range

3. **Update filter:**
   - filter.setParams(cutoffHz, resonanceParam, args.sampleRate)

4. **Process audio:**
   - input = inputs[AUDIO_INPUT].getVoltage()
   - Clamp input to +/-12V (VCV standard)
   - output = filter.process(input)
   - outputs[LP_OUTPUT].setVoltage(output)

5. **Other outputs (stub for now):**
   - HP, BP, NOTCH outputs: setVoltage(0.f) with comment "// Phase 3: multi-mode outputs"

Do NOT implement drive parameter yet (Phase 7).
Do NOT implement resonance CV yet (Phase 6).
Do NOT implement polyphony yet (Phase 4).
  </action>
  <verify>`make` compiles without errors. Module loads in VCV Rack without crash.</verify>
  <done>HydraQuartetVCF.cpp includes SVFilter.hpp, has filter member, process() reads cutoff/resonance params, applies CV modulation with attenuverter, and outputs lowpass filtered audio.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify filter operation</name>
  <what-built>
    SEM-style 12dB state-variable filter with:
    - Lowpass output
    - Cutoff knob (20Hz-20kHz)
    - Cutoff CV input with attenuverter
    - Resonance knob (subtle to self-oscillation)
  </what-built>
  <how-to-verify>
    1. Open VCV Rack and add HydraQuartet VCF-OB module
    2. Connect an oscillator (VCO-1 or similar) to Audio input
    3. Connect LP output to audio interface or Scope
    4. **Test cutoff sweep:** Turn Cutoff knob from 0 to 100% - should sweep from dark/muffled to bright
    5. **Test resonance:** Increase Resonance to ~75% - filter should "ring" and emphasize frequencies near cutoff
    6. **Test self-oscillation:** Turn Resonance to 100%, remove audio input - filter should produce audible sine tone
    7. **Test CV modulation:** Connect LFO to Cutoff CV, adjust attenuverter - cutoff should modulate with LFO
    8. **Test stability:** Sweep cutoff rapidly while resonance is high - filter should NOT blow up, crackle excessively, or go silent
  </how-to-verify>
  <resume-signal>Type "approved" if filter works correctly, or describe issues encountered</resume-signal>
</task>

</tasks>

<verification>
Phase 2 success criteria from ROADMAP.md:
1. Audio passes through module with lowpass filtering applied
2. Filter processes input signal and produces audible lowpass output
3. Filter remains stable (no blow-up, NaN, or crashes)
4. Self-oscillation produces audible tone at high resonance

All criteria verified through human testing in Task 3.
</verification>

<success_criteria>
- [ ] `make` compiles without errors
- [ ] Module loads in VCV Rack
- [ ] Audio input -> LP output produces audible filtered signal
- [ ] Cutoff knob sweeps filter frequency (dark to bright)
- [ ] Resonance knob adds emphasis and reaches self-oscillation at max
- [ ] Cutoff CV + attenuverter modulates filter frequency
- [ ] No crashes, NaN, or instability during normal operation
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-filter-dsp/02-01-SUMMARY.md`
</output>
